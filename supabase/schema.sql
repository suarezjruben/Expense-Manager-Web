create schema if not exists expense_manager;

grant usage on schema expense_manager to anon, authenticated, service_role;
grant all on all tables in schema expense_manager to anon, authenticated, service_role;
grant all on all sequences in schema expense_manager to anon, authenticated, service_role;

alter default privileges in schema expense_manager grant all on tables to anon, authenticated, service_role;
alter default privileges in schema expense_manager grant all on sequences to anon, authenticated, service_role;

create table if not exists expense_manager.accounts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  institution_name text,
  last4 text,
  active boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, name)
);

create table if not exists expense_manager.categories (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  type text not null check (type in ('EXPENSE', 'INCOME')),
  sort_order integer not null default 0,
  active boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, type, name)
);

create table if not exists expense_manager.month_settings (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  starting_balance numeric(12, 2) not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, month_key)
);

create table if not exists expense_manager.plans (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  category_id bigint not null references expense_manager.categories (id) on delete restrict,
  planned_amount numeric(12, 2) not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, month_key, category_id)
);

create table if not exists expense_manager.import_batches (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  account_id bigint not null references expense_manager.accounts (id) on delete restrict,
  source_name text not null,
  status text not null,
  inserted_count integer not null default 0,
  skipped_duplicates integer not null default 0,
  parse_error_count integer not null default 0,
  warning_count integer not null default 0,
  created_at timestamptz not null default now(),
  completed_at timestamptz
);

create table if not exists expense_manager.transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  type text not null check (type in ('EXPENSE', 'INCOME')),
  txn_date date not null,
  amount numeric(12, 2) not null,
  description text not null,
  category_id bigint not null references expense_manager.categories (id) on delete restrict,
  account_id bigint not null references expense_manager.accounts (id) on delete restrict,
  source_external_id text,
  dedupe_fingerprint text,
  import_batch_id bigint references expense_manager.import_batches (id) on delete set null,
  created_at timestamptz not null default now()
);

create table if not exists expense_manager.csv_mappings (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  account_id bigint not null references expense_manager.accounts (id) on delete cascade,
  date_column_index integer not null check (date_column_index >= 0),
  amount_column_index integer not null check (amount_column_index >= 0),
  description_column_index integer not null check (description_column_index >= 0),
  category_column_index integer check (category_column_index >= 0),
  external_id_column_index integer check (external_id_column_index >= 0),
  updated_at timestamptz not null default now(),
  unique (user_id, account_id)
);

create table if not exists expense_manager.import_issues (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  import_batch_id bigint not null references expense_manager.import_batches (id) on delete cascade,
  severity text not null check (severity in ('ERROR', 'WARNING')),
  row_number integer,
  message text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_accounts_user_id on expense_manager.accounts (user_id);
create index if not exists idx_categories_user_id on expense_manager.categories (user_id);
create index if not exists idx_month_settings_user_id_month_key on expense_manager.month_settings (user_id, month_key);
create index if not exists idx_plans_user_id_month_key on expense_manager.plans (user_id, month_key);
create index if not exists idx_transactions_user_id_month_key on expense_manager.transactions (user_id, month_key);
create index if not exists idx_transactions_user_id_account_id on expense_manager.transactions (user_id, account_id);
create index if not exists idx_transactions_source_external_id on expense_manager.transactions (user_id, account_id, source_external_id);
create index if not exists idx_transactions_dedupe_fingerprint on expense_manager.transactions (user_id, account_id, dedupe_fingerprint);
create index if not exists idx_csv_mappings_user_id_account_id on expense_manager.csv_mappings (user_id, account_id);
create index if not exists idx_import_batches_user_id on expense_manager.import_batches (user_id);
create index if not exists idx_import_issues_user_id on expense_manager.import_issues (user_id);

alter table expense_manager.accounts enable row level security;
alter table expense_manager.categories enable row level security;
alter table expense_manager.month_settings enable row level security;
alter table expense_manager.plans enable row level security;
alter table expense_manager.transactions enable row level security;
alter table expense_manager.csv_mappings enable row level security;
alter table expense_manager.import_batches enable row level security;
alter table expense_manager.import_issues enable row level security;

drop policy if exists "accounts user access" on expense_manager.accounts;
create policy "accounts user access" on expense_manager.accounts
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "categories user access" on expense_manager.categories;
create policy "categories user access" on expense_manager.categories
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "month_settings user access" on expense_manager.month_settings;
create policy "month_settings user access" on expense_manager.month_settings
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "plans user access" on expense_manager.plans;
create policy "plans user access" on expense_manager.plans
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "transactions user access" on expense_manager.transactions;
create policy "transactions user access" on expense_manager.transactions
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "csv_mappings user access" on expense_manager.csv_mappings;
create policy "csv_mappings user access" on expense_manager.csv_mappings
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "import_batches user access" on expense_manager.import_batches;
create policy "import_batches user access" on expense_manager.import_batches
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "import_issues user access" on expense_manager.import_issues;
create policy "import_issues user access" on expense_manager.import_issues
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);
