create table if not exists public.accounts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  institution_name text,
  last4 text,
  active boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, name)
);

create table if not exists public.categories (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  type text not null check (type in ('EXPENSE', 'INCOME')),
  sort_order integer not null default 0,
  active boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, type, name)
);

create table if not exists public.month_settings (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  starting_balance numeric(12, 2) not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, month_key)
);

create table if not exists public.plans (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  category_id bigint not null references public.categories (id) on delete restrict,
  planned_amount numeric(12, 2) not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, month_key, category_id)
);

create table if not exists public.import_batches (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  account_id bigint not null references public.accounts (id) on delete restrict,
  source_name text not null,
  status text not null,
  inserted_count integer not null default 0,
  skipped_duplicates integer not null default 0,
  parse_error_count integer not null default 0,
  warning_count integer not null default 0,
  created_at timestamptz not null default now(),
  completed_at timestamptz
);

create table if not exists public.transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  month_key text not null check (month_key ~ '^\d{4}-\d{2}$'),
  type text not null check (type in ('EXPENSE', 'INCOME')),
  txn_date date not null,
  amount numeric(12, 2) not null,
  description text not null,
  category_id bigint not null references public.categories (id) on delete restrict,
  account_id bigint not null references public.accounts (id) on delete restrict,
  source_external_id text,
  dedupe_fingerprint text,
  import_batch_id bigint references public.import_batches (id) on delete set null,
  created_at timestamptz not null default now()
);

create table if not exists public.csv_mappings (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  account_id bigint not null references public.accounts (id) on delete cascade,
  date_column_index integer not null check (date_column_index >= 0),
  amount_column_index integer not null check (amount_column_index >= 0),
  description_column_index integer not null check (description_column_index >= 0),
  category_column_index integer check (category_column_index >= 0),
  external_id_column_index integer check (external_id_column_index >= 0),
  updated_at timestamptz not null default now(),
  unique (user_id, account_id)
);

create table if not exists public.import_issues (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  import_batch_id bigint not null references public.import_batches (id) on delete cascade,
  severity text not null check (severity in ('ERROR', 'WARNING')),
  row_number integer,
  message text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_accounts_user_id on public.accounts (user_id);
create index if not exists idx_categories_user_id on public.categories (user_id);
create index if not exists idx_month_settings_user_id_month_key on public.month_settings (user_id, month_key);
create index if not exists idx_plans_user_id_month_key on public.plans (user_id, month_key);
create index if not exists idx_transactions_user_id_month_key on public.transactions (user_id, month_key);
create index if not exists idx_transactions_user_id_account_id on public.transactions (user_id, account_id);
create index if not exists idx_transactions_source_external_id on public.transactions (user_id, account_id, source_external_id);
create index if not exists idx_transactions_dedupe_fingerprint on public.transactions (user_id, account_id, dedupe_fingerprint);
create index if not exists idx_csv_mappings_user_id_account_id on public.csv_mappings (user_id, account_id);
create index if not exists idx_import_batches_user_id on public.import_batches (user_id);
create index if not exists idx_import_issues_user_id on public.import_issues (user_id);

alter table public.accounts enable row level security;
alter table public.categories enable row level security;
alter table public.month_settings enable row level security;
alter table public.plans enable row level security;
alter table public.transactions enable row level security;
alter table public.csv_mappings enable row level security;
alter table public.import_batches enable row level security;
alter table public.import_issues enable row level security;

drop policy if exists "accounts user access" on public.accounts;
create policy "accounts user access" on public.accounts
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "categories user access" on public.categories;
create policy "categories user access" on public.categories
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "month_settings user access" on public.month_settings;
create policy "month_settings user access" on public.month_settings
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "plans user access" on public.plans;
create policy "plans user access" on public.plans
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "transactions user access" on public.transactions;
create policy "transactions user access" on public.transactions
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "csv_mappings user access" on public.csv_mappings;
create policy "csv_mappings user access" on public.csv_mappings
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "import_batches user access" on public.import_batches;
create policy "import_batches user access" on public.import_batches
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "import_issues user access" on public.import_issues;
create policy "import_issues user access" on public.import_issues
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);
